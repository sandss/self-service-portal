# Alembic Migration Guide

## Overview
This project uses Alembic for database schema migrations with SQLAlchemy models.

## Current State
- ✅ Alembic initialized and configured
- ✅ Baseline migration applied (creates initial catalog tables)
- ✅ PostgreSQL running with tables created

## Generating New Migrations

### 1. Manual Command
```bash
# Navigate to project root
cd /mnt/d/Users/scshh/Projects/wwt/portal_test/self-service-portal

# Ensure database is running
docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d postgres

# Generate migration (after modifying models)
poetry run alembic revision --autogenerate -m "describe your changes"

# Apply migration
poetry run alembic upgrade head
```

### 2. Using the Script
```bash
# Generate migration with description
./scripts/generate_migration.sh "add catalog item tags column"
```

## Example Workflow

### Scenario: Adding a new column to CatalogItem

1. **Modify the model** in `api/catalog/models.py`:
```python
class CatalogItem(Base):
    # ... existing fields ...
    tags = Column(postgresql.JSONB, nullable=True)  # NEW FIELD
```

2. **Generate migration**:
```bash
poetry run alembic revision --autogenerate -m "add tags column to catalog items"
```

3. **Review generated migration** in `alembic/versions/`:
```python
def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('catalog_items', sa.Column('tags', postgresql.JSONB(astext_type=sa.Text()), nullable=True))
    # ### end Alembic commands ###
```

4. **Apply migration**:
```bash
poetry run alembic upgrade head
```

## Important Notes

### What Alembic Detects Automatically
- ✅ New tables/models
- ✅ Dropped tables/models  
- ✅ New columns
- ✅ Dropped columns
- ✅ Column type changes
- ✅ Index changes
- ✅ Foreign key changes

### What Alembic Cannot Detect
- ❌ Column renames (shows as drop + add)
- ❌ Table renames (shows as drop + add)
- ❌ Constraint name changes
- ❌ Custom SQL operations

### Manual Adjustments
Sometimes you need to manually edit generated migrations:

```python
def upgrade() -> None:
    # Instead of drop + add for rename:
    # op.drop_column('catalog_items', 'old_name')
    # op.add_column('catalog_items', sa.Column('new_name', sa.String(), nullable=True))
    
    # Do this for rename:
    op.alter_column('catalog_items', 'old_name', new_column_name='new_name')
```

## Migration Commands

```bash
# Check current migration status
poetry run alembic current

# Show migration history
poetry run alembic history

# Show pending migrations
poetry run alembic heads

# Upgrade to specific revision
poetry run alembic upgrade <revision_id>

# Downgrade to previous revision
poetry run alembic downgrade -1

# Show SQL without executing
poetry run alembic upgrade head --sql
```

## Testing Migrations

### 1. Test Forward Migration
```bash
# Apply migration
poetry run alembic upgrade head

# Verify tables/columns exist
docker exec -it self-service-portal-postgres-1 psql -U portal_user -d portal_db -c "\d catalog_items"
```

### 2. Test Rollback
```bash
# Downgrade
poetry run alembic downgrade -1

# Verify changes reverted
docker exec -it self-service-portal-postgres-1 psql -U portal_user -d portal_db -c "\d catalog_items"

# Re-apply
poetry run alembic upgrade head
```

## Troubleshooting

### Common Issues

1. **"Target database is not up to date"**
```bash
poetry run alembic stamp head  # Mark current state as up-to-date
```

2. **"Can't locate revision identified by 'xyz'"**
```bash
poetry run alembic heads  # Check available revisions
poetry run alembic upgrade head  # Sync to latest
```

3. **PostgreSQL connection errors**
```bash
# Ensure database is running
docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d postgres

# Check logs
docker logs self-service-portal-postgres-1
```

4. **Import errors in migrations**
```bash
# Ensure all models are imported in alembic/env.py
# Check that PYTHONPATH includes the project root
```

## Best Practices

1. **Always review** generated migrations before applying
2. **Test migrations** on a copy of production data
3. **Keep migrations small** and focused
4. **Write descriptive** migration messages
5. **Never edit** applied migrations (create new ones instead)
6. **Backup database** before major migrations
7. **Test rollbacks** for critical migrations
